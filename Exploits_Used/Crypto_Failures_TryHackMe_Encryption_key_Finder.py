import socket
import re
import urllib.parse
import crypt
from math import floor
from time import time, sleep
from concurrent.futures import ThreadPoolExecutor, as_completed
from rich.console import Console

# ========== CONFIG ==========
HOST = "crypto.thm"
PORT = 80
USERNAME = "guest:"
SEPARATOR = ":"
CHARSET = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!@#$%^&*()_+-=[]{}|;:,.<>?"
TIMEOUT = 5
THREADS = 20
# ============================

console = Console()


def send_request(user_agent: str) -> str | None:
    """Send HTTP request and return decoded secure_cookie."""
    req = (
        f"GET / HTTP/1.1\r\n"
        f"Host: {HOST}\r\n"
        f"User-Agent: {user_agent}\r\n"
        f"Accept: */*\r\n"
        f"Connection: close\r\n\r\n"
    )

    try:
        with socket.create_connection((HOST, PORT), timeout=TIMEOUT) as sock:
            sock.sendall(req.encode())
            response = b""
            while True:
                chunk = sock.recv(1024)
                if not chunk:
                    break
                response += chunk
    except Exception:
        return None

    match = re.search(rb"Set-Cookie: secure_cookie=([^;]+)", response)
    if match:
        cookie = match.group(1).decode()
        return urllib.parse.unquote(cookie)
    return None


def split_blocks(cookie: str) -> list[str]:
    return [cookie[i:i + 13] for i in range(0, len(cookie), 13)]


def try_char(candidate_char, prefix, salt, target_block):
    candidate = prefix + candidate_char
    block = candidate[-8:]
    hashed = crypt.crypt(block, salt)
    if hashed == target_block:
        return candidate_char
    return None


def brute_force_key():
    known_key = ""
    position = 0
    start_time = time()

    console.print("[bold cyan]üîì Starting secure_cookie brute-force...[/]\n")

    while True:
        prefix_len = len(USERNAME + SEPARATOR + known_key)
        pad_len = ((7 - prefix_len) % 8 + 8) % 8
        user_agent = "A" * pad_len
        prefix = USERNAME + user_agent + SEPARATOR + known_key

        cookie = send_request(user_agent)
        if not cookie:
            console.print("[bold red][!] Failed to retrieve cookie. Exiting.[/]")
            break

        blocks = split_blocks(cookie)
        block_idx = floor(len(prefix) / 8)

        if block_idx >= len(blocks):
            console.print(f"\n[bold yellow][‚úì] Key might be complete: [white]{known_key}[/][/]")
            break

        target_block = blocks[block_idx]
        salt = target_block[:2]

        console.print(
            f"[white][>] Brute-forcing block {block_idx}[/] "
            f"[dim]| Salt:[/] {salt} [dim]| Known:[/] [green]{known_key}[/]"
        )

        found_char = None
        with ThreadPoolExecutor(max_workers=THREADS) as executor:
            futures = {
                executor.submit(try_char, ch, prefix, salt, target_block): ch
                for ch in CHARSET
            }

            for future in as_completed(futures):
                result = future.result()
                if result:
                    found_char = result
                    break

        if found_char:
            known_key += found_char
            console.print(f"[bold green][‚úì] Found character:[/] '{found_char}' ‚Üí [cyan]{known_key}[/]")
        else:
            console.print(f"[bold yellow][!] Couldn't find next character. Final key: {known_key}[/]")
            break

        position += 1
        sleep(0.05)  # just enough to avoid socket issues on some servers

    console.print(
        f"\n[bold green]‚úî Brute-force complete! Final Key:[/] [white]{known_key}[/]\n"
        f"[dim]‚è± Time taken: {time() - start_time:.2f} seconds[/]"
    )


if __name__ == "__main__":
    try:
        brute_force_key()
    except KeyboardInterrupt:
        console.print("\n[bold red][!] Interrupted by user. Exiting...[/]")
